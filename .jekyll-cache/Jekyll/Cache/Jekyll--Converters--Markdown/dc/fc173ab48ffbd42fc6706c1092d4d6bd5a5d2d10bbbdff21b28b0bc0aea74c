I"s<h1 id="spring-framework-정리">Spring Framework 정리</h1>

<p><img src="/assets/img/titles/spring-logo.svg" alt="spring-logo.svg" /></p>

<hr />

<h2 id="spring이란">Spring이란?</h2>

<h3 id="spring이-뭐지">Spring이 뭐지?</h3>

<p><img src="/assets/img/contents/sf-1.png" alt="sf-1.png" /></p>

<p>스프링이란 Spring Framework를 의미하기도 하지만 더 나아가 Spring Boot, Spring Data, Spring Cloud, Spring Batch 등 다양한 스프링 프로젝트를 포함하는 스프링 생태계(Spring Ecosystem)를 말한다.</p>

<p>초기에는 스프링 프레임워크로 시작을 하였으나 점차 모듈/프로젝트들이 추가되었고 현재의 다양한 스프링 프로젝트가 존재하는 스프링 생태계를 구성하게 되었다.</p>

<blockquote>
  <p><a href="https://github.com/orgs/spring-projects/repositories">Spring Projects Github</a></p>

  <p>스프링 프로젝트들은 오픈소스 생태계를 구성하고 있어 활발하게 확장되고 있다.</p>
</blockquote>

<p>통상적으로 Spring를 말할때는 Spring Framework를 의미하고 추가적인 프로젝트들은 Spring Data, Spring Cloud등의 이름으로 부르고 있다.</p>

<blockquote>
  <p><a href="https://spring.io/projects">spring.io/projects</a></p>

  <p>어떤 프로젝트가 있는지는 spring.io 공식 홈페이지에서 확인할 수 있다.</p>
</blockquote>

<hr />

<h2 id="spring-등장-배경">Spring 등장 배경</h2>

<p>스프링 탄생 이전에는 자바를 이용한 엔터프라이즈 앱/서비스를 개발할 때 J2EE(Java EE)를 사용해야만 했다.</p>

<p><img src="/assets/img/contents/sf-7.png" alt="sf-7.png" /></p>

<p>EJB의 개념은 매우 뛰어났으나 스프링 등장 이전의 EJB v1, v2는</p>

<p>EJB를 구현하기 위해서는 XML 디스크립터 작성, 홈 인터페이스, 컴포넌트 인터페이스를 생성 등의 과정이 있어 매우 복잡하였고 이는 곧 느린 성능을 의미하였다.</p>

<p>이런 복잡한 EJB에 대한 대안으로 POJO(Plain Old Java Object) 객체를 사용하는 것이 낫다는 주장이 나왔다.</p>

<blockquote>
  <p><strong>POJO(Plain Old Java Object)?</strong></p>

  <p><a href="https://martinfowler.com/bliki/POJO.html">https://martinfowler.com/bliki/POJO.html</a></p>

  <p>POJO는 종속성이 없는 일반 자바 클래스 객체를 말하는 것이며 그다지 새로운 개념이 아니다.</p>

  <p>마틴 파울러(Martin Folwer)는 비즈니스 로직을 구현할 때 일반 자바 객체를 사용하는 것이 EJB를 사용하는 것 보다 훨씬 많은 장점을 가지고 있다고 생각하였고</p>

  <p>사람들이 일반 자바 객체를 사용하는 것을 망설이는 이유가 그럴듯한 이름이 없다고 생각하였다.</p>

  <p>그래서 그럴듯한 이름을 붙여주었더니 아주 잘 나갔다는 후문</p>
</blockquote>

<p>Spring은 J2EE에 대한 간단하고 가벼운 대안으로 POJO기반의 여러가지의 헬퍼 클래스를 제공하는데서 시작하였다.</p>

<p>2004년에 Spring 1.0을 시작으로 현재는 Spring 5까지 나왔으며</p>

<p>추후에는 Java EE가 역으로 Spring의 영향을 받아서 EJB를 갈아 엎었으며 현재는 Java EE도 스프링과 매우 유사한 기능을 제공하고 있다.</p>

<p>하지만 예전의 EJB의 악평과 그 사이에 스프링 프레임워크가 매우 큰 인기를 끌게 되어 Java EE를 이용하는 비율은 많이 줄어들었다.</p>

<hr />

<h2 id="spring-framework">Spring Framework?</h2>

<p><img src="/assets/img/contents/sf-2.png" alt="sf-2.png" /></p>

<p>일반적으로 말하는 Spring이란 Spring 프로젝트의 출발점이자 핵심인 Spring Framework를 일컫는다.</p>

<p>스프링 프레임워크의 모듈들은 위와같이 구성된다.</p>

<p><br /></p>

<h3 id="1-spring-core">1. Spring Core</h3>

<p>Spring의 기본이자 핵심 모듈로 Spring Container, IoC Container이다.</p>

<p>스프링 프레임워크에서 지원하는 IoC, DI 등의 개념의 주체인 Bean을 관리하는 핵심 기능을 담당한다.</p>

<blockquote>
  <p><strong>Spring Bean?</strong></p>

  <p>Spring Framework에서 관리하는 자바 객체로 일반 자바 클래스와 같다고 생각하면 된다.</p>

  <p>Spring에서는 기존의 J2EE의 EJB 방식의 복잡한 구현을 피하기 위하여 POJO를 사용하는데</p>

  <p>해당 POJO가 Spring Container에 의해 생성되고 관리되면 해당 객체는 Bean이라고 한다.</p>
</blockquote>

<p>아래와 같은 4가지 모듈로 구성된다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">spring-core</code>, <code class="language-plaintext highlighter-rouge">spring-beans</code>
    <ul>
      <li>스프링 프레임워크의 핵심 기능 IoC, DI를 지원한다.</li>
      <li>BeanFactory를 구현하여 Bean을 싱글턴 객체로 관리하므로 프로그래밍적으로 객체를 관리할 필요가 없다.</li>
      <li>프로그램 로직/비즈니스 로직과 객체의 생성/관리를 분리하는 핵심 기능</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-context</code>
    <ul>
      <li>위에서 생성한 Bean의 라이프사이클, 스코프인 <code class="language-plaintext highlighter-rouge">ApplicationContext</code>등의 인터페이스를 제공한다.</li>
      <li>스프링 컨테이너에서 관리하는 스프링 빈들을 사용하기 위한 인터페이스이다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-expression</code>
    <ul>
      <li>JSP 명세에 의한 EL(Expression Language)의 확장 기능을 제공한다.</li>
      <li>모델, 빈 객체에 쿼리하고 접근하기 위한 EL로 스프링 컨테이너의 오브젝트와 프로퍼티, 변수, 사칙연산 등을 제공한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="2-spring-aop">2. Spring AOP</h3>

<p>스프링에서 DI, IoC와 함께 주요 개념인 AOP(Aspect Oriented Programming): 관점 지향 프로그래밍 기능을 제공한다. pointcut과 메소드 인터셉터들을 지원한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">spring-aop</code>
    <ul>
      <li>AOP의 구현체로 포인트컷, 인터셉터 등을 지원한다.</li>
      <li>AOP를 이용하여 소스코드에서 AOP 공통 부분을 분리할 수 있다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-aspects</code>
    <ul>
      <li>AspectJ를 지원하는 모듈이다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-instruments</code>
    <ul>
      <li>Tomcat과 같은 미들웨어 서버에서의 클래스로더 구현체를 제공한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="3-spring-messaging">3. Spring Messaging</h3>

<ul>
  <li>Spring Integration 프로젝트의 추상체를 제공하여 메시지 기반의 어플리케이션을 지원한다.</li>
</ul>

<p><br /></p>

<h3 id="4-spring-dao">4. Spring DAO</h3>

<p>영속성 데이터 접근/통합,  트랜잭션 처리, ORM 등을 지원한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">spring-jdbc</code>
    <ul>
      <li>스프링에서는 DB에 접근하기 위한 추상화 프레임워크로 JDBC라는 것을 사용한다.</li>
      <li>각 DB별 Driver를 구현하여 데이터베이스에 접근, 에러코드 파싱이 가능하다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-tx</code>
    <ul>
      <li>POJO에 트랜잭션 처리를 위한 어노테이션 및 인터페이스를 제공한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-orm</code>
    <ul>
      <li>JPA, Hibernate와 같은 ORM(객체관계 매핑) 인터페이스를 제공한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-oxm</code>
    <ul>
      <li>JAXB, Castor와 같은 OXM(객체 XML 매핑) 인터페이스를 제공한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-jms</code>
    <ul>
      <li>메시지 프로듀싱, 컨슈밍을 담당한다.</li>
      <li>Spring 4.1 이후로 Spring Messaging 모듈과 통합되었다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="5-spring-web">5. Spring Web</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">spring-web</code>
    <ul>
      <li>서블릿 리스너, 웹 기반 IoC 컨테이너, 웹 Context, HTTP 클라이언트를 제공한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">spring-webmvc</code>
    <ul>
      <li>Spring MVC라고도 부르며 Spring MVC와 REST 웹서비스 구현체를 포함한다.</li>
      <li>화면단과 도메인 모델, 로직을 구분하기 위하여 Model, View, Controller를 나누어 사용하는 MVC 패턴이 적용된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="6-spring-test">6. Spring Test</h3>

<ul>
  <li>JUnit, TestNG 같은 단위 테스트, 통합 테스트 라이브러리를 지원하는 모듈로 Mock 객체와 단위테스트시 Spring Container, 스프링 빈에 접근하기 위한 ApplicationContext를 제공한다.</li>
</ul>

<hr />

<h2 id="spring-core">Spring Core</h2>

<p><img src="/assets/img/contents/sf-3.png" alt="sf-3.png" /></p>

<p>Spring Framework의 핵심 모듈인 Spring Core에 대해서 알아본다.</p>

<p>일반적으로 스프링 프레임워크의 IoC, DI 등의 핵심 기능을 해당 모듈에서 담당한다.</p>

<p>스프링 컨테이너, IoC 컨테이너 그 자체라고 보아도 무방하다.</p>

<p><br /></p>

<h3 id="inversion-of-controlioc">Inversion Of Control(IoC)</h3>

<p><strong>제어의 역전; 객체의 생성과 관리를 외부에 맡기는 것</strong></p>

<p><br /></p>

<h4 id="ioc-개념-도입-전">IoC 개념 도입 전</h4>

<div class="mermaid">
  flowchart LR
    A[Application]
    B[Class A]
    A--new Class A--&gt;B
    B-.return Instance A.-&gt;A
</div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// POJO</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nf">Cat</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Constructed!"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nc">Cat</span> <span class="n">myCat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cat</span><span class="o">();</span>

<span class="c1">// 출력</span>
<span class="nc">Constructed</span><span class="o">!</span>
</code></pre></div></div>

<p>기존 초기 자바 어플리케이션의 경우 위와 같이 개발자가 객체의 생성과 초기화 등의 라이프사이클을 관리해주어야 하였다.</p>

<p>하지만 이런 방식은 생성된 객체(인스컨스)을 여러 클래스에서 사용 및 관리하기가 힘들고 또한 여러개의 중복된 객체가 생성될 가능성이 있다.</p>

<p><br /></p>

<h4 id="ioc-개념-도입-후">IoC 개념 도입 후</h4>

<div class="mermaid">
  flowchart LR
    A[Application]
    B[Spring Container]
    C[XML Configuration]
    D[Bean]
    C--1. Metadata--&gt;B
    B--2. Generate---D
    A--3. getBean--&gt;B
    B-.4. Bean.-&gt;A
</div>

<p><br /></p>

<p><img src="/assets/img/contents/sf-4.png" alt="sf-4.png" /></p>

<p>이를 해결하기 위하여 스프링에서는 모든 객체의 생성과 관리를 Bean으로 등록하여 스프링 컨테이너에게 위임한다. 이를 제어의 역전(Inversion Of Control)이라고 한다.</p>

<p>제어의 역전이라는 특성을 통하여 개발자는 더 이상 객체의 생성과 관리에 대하여 신경쓰지 않고 비즈니스 로직에만 집중하여 생산성을 높일 수 있다.</p>

<p><br /></p>

<h4 id="xml-설정-예시">XML 설정 예시</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
    <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span> 
    <span class="na">xmlns:context=</span><span class="s">"http://www.springframework.org/schema/context"</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="nt">&gt;</span>
  
	<span class="c">&lt;!-- 역전 제어 --&gt;</span>
	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"cat"</span> <span class="na">class=</span><span class="s">"com.csupreme19.springdemo.Cat"</span> <span class="nt">/&gt;</span>
    
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>
<span class="nc">Cat</span> <span class="n">myCat</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="nc">Cat</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// 출력</span>
<span class="nc">Constructed</span><span class="o">!</span>
</code></pre></div></div>

<p>빈은 어플리케이션의 실행과 종료까지의 생명주기를 가지는 ApplicationContext에 등록되어 사용되고 해당 ApplicationContext는 XML 파일, 어노테이션, 자바 코드 등으로 설정할 수 있다.</p>

<p>컨텍스트 생성 시점 Bean들을 주입(생성)하여 초기화하며 컨텍스트에서 <code class="language-plaintext highlighter-rouge">getBean()</code> 호출시 스프링 컨테이너에 객체가 존재하는지 확인하고 객체를 가져온다.</p>

<p>이를 통해 개발자는 더 이상 객체의 생성과  관리에 대해서 걱정할 필요가 없이 싱글턴 객체를 사용할 수 있다.</p>

<p><br /></p>

<h3 id="dependency-injectiondi">Dependency Injection(DI)</h3>

<p><strong>의존성 주입; 객체의 의존성을 주입하는 것</strong></p>

<p>스프링 컨테이너에 빈을 등록하여 관리하는데 해당 Bean이 POJO 형태가 아니라 여러 Dependency를 가지고 있으면 어떻게 될까?</p>

<p>모두 알고 있듯이 객체지향 관점에서 대부분의 객체는 의존성을 가지고 있다.</p>

<p>해당 객체는 스프링 컨테이너에서 사용 못하고 개발자가 직접 수동으로 생성해야 할까?</p>

<p>이러한 의존성을 해결하기 위하여 의존성 주입이라는 개념이 등장한다.</p>

<div class="mermaid">
  flowchart LR
    A[Application]
    B[Spring Container]
    C[XML Configuration]
    D[Cat Bean]
    E[Eye Bean]
    C--1. Metadata--&gt;B
    B--2. Generate---E
    B--2. Generate---D
    E--3. Dependency Inject--&gt;D
    A--4. getBean--&gt;B
    B-.5. Bean.-&gt;A
</div>

<ol>
  <li>초기 스프링 컨테이너 구동시 스프링 컨테이너에 의해 모든 Bean이 생성된다.</li>
  <li>이후 DI를 통해 의존성을 주입하여 의존성이 주입된 Bean이 준비된다.</li>
  <li>스프링 컨테이너에서 getBean을 통하여 사용하는 모든 Bean은 DI가 완료된 빈이다.</li>
</ol>

<p><br /></p>

<h4 id="constructor-dependency-injection-예시">Constructor Dependency Injection 예시</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"eye"</span> <span class="na">class=</span><span class="s">"com.csupreme19.springdemo.Eye"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"cat"</span> <span class="na">class=</span><span class="s">"com.csupreme19.springdemo.Cat"</span><span class="nt">&gt;</span>
	<span class="c">&lt;!-- 의존성 주입 --&gt;</span>
	<span class="nt">&lt;constructor-arg</span> <span class="na">ref=</span><span class="s">"eye"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">gender</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nc">Eye</span> <span class="n">eye</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Cat</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Constructed!"</span><span class="o">);</span>
  <span class="o">}</span>
	
	<span class="kd">public</span> <span class="nf">Cat</span><span class="o">(</span><span class="nc">Eye</span> <span class="n">eye</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Constructed!"</span><span class="o">);</span>
		<span class="k">this</span><span class="o">.</span><span class="na">eye</span><span class="o">=</span><span class="n">eye</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="nc">Cat</span> <span class="n">myCat</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="nc">Cat</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myCat</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myCat</span><span class="o">.</span><span class="na">eye</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</code></pre></div></div>

<p>Cat에 Eye라는 dependency를 추가하였다.</p>

<p>스프링의 DI를 사용하려면 해당 Eye 또한 Bean으로 등록되어 있어야 이후 DI 시점에 주입이 될 수 있다.</p>

<p><br /></p>

<h3 id="bean-scope">Bean Scope</h3>

<h4 id="singleton">Singleton</h4>

<div class="mermaid">
  flowchart LR
    A[Class B]
    B[Class C]
    C[Class D]
    D[Spring Container]
    F[Instance A]
    A--getBean--&gt;D
    B--getBean--&gt;D
    C--getBean--&gt;D
    D&lt;-.manage.-&gt;F
</div>

<p>스프링 컨테이너는 기본적으로 단일 빈 정의에 대해서 단 하나의 빈 객체(인스턴스)만을 관리한다.</p>

<p>이는 GoF 디자인 패턴의 싱글톤 패턴에 해당하며 컨텍스트에서 단일 인스턴스만을 참조하여 객체의 중복생성을 피하고 관리를 쉽게 해준다.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 두 가지는 서로 동일(기본 스코프는 싱글톤) --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"eye"</span> <span class="na">class=</span><span class="s">"com.csupreme19.springdemo.Eye"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"eye"</span> <span class="na">class=</span><span class="s">"com.csupreme19.springdemo.Eye"</span> <span class="na">scope=</span><span class="s">"singleton"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>
<span class="nc">Cat</span> <span class="n">myCat</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="nc">Cat</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Cat</span> <span class="n">yourCat</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="nc">Cat</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myCat</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">yourCat</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>

<span class="c1">// 서로 같은 메모리를 참조하는 동일 인스턴스임을 확인</span>
<span class="n">com</span><span class="o">.</span><span class="na">csupreme19</span><span class="o">.</span><span class="na">springdemo</span><span class="o">.</span><span class="na">Cat</span><span class="err">@</span><span class="mi">1</span><span class="n">ed4ae0f</span>
<span class="n">com</span><span class="o">.</span><span class="na">csupreme19</span><span class="o">.</span><span class="na">springdemo</span><span class="o">.</span><span class="na">Cat</span><span class="err">@</span><span class="mi">1</span><span class="n">ed4ae0f</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="prototype">Prototype</h4>

<div class="mermaid">
  flowchart LR
    A[Class B]
    B[Class C]
    C[Class D]
    subgraph Spring Container
    D[Spring Container]
    I[Spring Container]
    J[Spring Container]
    end
    F[Instance A]
    G[Instance A']
    H[Instance A'']
    A--getBean--&gt;D
    B--getBean--&gt;I
    C--getBean--&gt;J
    D&lt;-.manage.-&gt;F
    I&lt;-.manage.-&gt;G
    J&lt;-.manage.-&gt;H
</div>

<p>스프링에서는 또다른 빈 스코프가 있는데 Prototype 스코프이다.</p>

<p>각 스코프별로 컨테이너에 객체가 참조될 때마다 새로운 인스턴스가 생성된다.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"eye"</span> <span class="na">class=</span><span class="s">"com.csupreme19.springdemo.Eye"</span> <span class="na">scope=</span><span class="s">"prototype"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Cat</span> <span class="n">myCat</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="nc">Cat</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Cat</span> <span class="n">yourCat</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="nc">Cat</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myCat</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">yourCat</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myCat</span><span class="o">.</span><span class="na">eye</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">yourCat</span><span class="o">.</span><span class="na">eye</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>

<span class="c1">// 서로 다른 인스턴스임을 확인</span>
<span class="n">com</span><span class="o">.</span><span class="na">csupreme19</span><span class="o">.</span><span class="na">springdemo</span><span class="o">.</span><span class="na">Cat</span><span class="err">@</span><span class="mi">1</span><span class="n">ed4ae0f</span>
<span class="n">com</span><span class="o">.</span><span class="na">csupreme19</span><span class="o">.</span><span class="na">springdemo</span><span class="o">.</span><span class="na">Cat</span><span class="err">@</span><span class="mi">54</span><span class="n">c5a2ff</span>
<span class="c1">// 하지만 주입된 singleton 빈은 같은 인스턴스임을 확인할 수 있다.</span>
<span class="n">com</span><span class="o">.</span><span class="na">csupreme19</span><span class="o">.</span><span class="na">springdemo</span><span class="o">.</span><span class="na">Eye</span><span class="err">@</span><span class="mi">6</span><span class="n">d4d66d2</span>
<span class="n">com</span><span class="o">.</span><span class="na">csupreme19</span><span class="o">.</span><span class="na">springdemo</span><span class="o">.</span><span class="na">Eye</span><span class="err">@</span><span class="mi">6</span><span class="n">d4d66d2</span>
</code></pre></div></div>

<blockquote>
  <p><strong>주의사항</strong></p>

  <p>Prototype 스코프 빈의 경우 스프링 컨테이너에서 라이프사이클을 보장하지 않는다.</p>
</blockquote>

<p>singleton, prototype 이외에도 request, session, global-session 등의 스코프가 존재한다.</p>

<p><br /></p>

<h3 id="bean-lifecycle">Bean Lifecycle</h3>

<div class="mermaid">
  sequenceDiagram
    participant A as Container Start
    participant B as Bean Instantiate
    participant C as Dependencies Inject
    participant D as Internal Spring Process
    participant E as Init Method
    participant F as Destroy Method
    participant G as Bean Destroy
  A-&gt;&gt;B: Instantiate beans
B-&gt;&gt;C: Inject dependencies
C-&gt;&gt;D: Bean factory
D-&gt;&gt;E: Custom initialization
loop until container stop
E-&gt;F: Beans ready to use
end
F-&gt;&gt;G: Custom destruction
</div>

<p>Bean은 다음과 같은 생명주기를 갖는다.</p>

<ol>
  <li>스프링 컨테이너 시작
    <ul>
      <li>어플리케이션이 시작되면 스프링 컨테이너도 함께 시작한다.</li>
    </ul>
  </li>
  <li>메타데이터에 의해 설정된 빈들을 생성한다.
    <ul>
      <li>XML 설정, @ComponentScan 등에 의해 설정된 메타데이터를 기반으로 Bean을 스프링 컨테이너에 생성한다.</li>
    </ul>
  </li>
  <li>해당 빈에 대한 의존성을 주입한다.
    <ul>
      <li>생성된 Bean들을 의존성으로 가지고 있는 빈에 의존성을 주입한다.</li>
    </ul>
  </li>
  <li>내부 프로세스 진행
    <ul>
      <li>빈 팩토리와 같은 post-processor를 실행한다.</li>
    </ul>
  </li>
  <li>init method 실행
    <ul>
      <li>해당 Bean에 설정된 init method를 실행한다.</li>
    </ul>
  </li>
  <li>스프링 컨테이너 중지
    <ul>
      <li>어플리케이션이 중지되면 스프링 컨테이너도 함께 중지된다.</li>
    </ul>
  </li>
  <li>destroy method 실행
    <ul>
      <li>해당 Bean에 설정된 destroy method를 실행한다.</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h4 id="생명주기-확인">생명주기 확인</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"testBean"</span> <span class="na">class=</span><span class="s">"com.csupreme19.springdemo.TestBean"</span> <span class="na">init-method=</span><span class="s">"printInit"</span> <span class="na">destroy-method=</span><span class="s">"printDestroy"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestBean</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="nf">TestBean</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">+</span> <span class="s">" Constructed!"</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">printInit</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">+</span> <span class="s">" Init bean!"</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">printDestroy</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">+</span> <span class="s">" Destroy bean!"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="nc">ApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>
<span class="nc">TestBean</span> <span class="n">testBean</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"testBean"</span><span class="o">,</span> <span class="nc">TestBean</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Closing Application Context!"</span><span class="o">);</span>
<span class="o">((</span><span class="nc">AbstractApplicationContext</span><span class="o">)</span> <span class="n">ctx</span><span class="o">).</span><span class="na">close</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Closed Application Context!"</span><span class="o">);</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class com.csupreme19.springdemo.TestBean Constructed!
class com.csupreme19.springdemo.TestBean Init bean!
com.csupreme19.springdemo.TestBean@54e1c68b
Closing Application Context!
class com.csupreme19.springdemo.TestBean Destroy bean!
Closed Application Context!
</code></pre></div></div>

<p>생성자 -&gt; Bean 초기화 메서드 -&gt; 빈 확인 -&gt; 컨테이너 종료시 빈 종료 확인</p>

<hr />

<h2 id="spring-aop">Spring AOP</h2>

<p><img src="/assets/img/contents/sf-5.png" alt="sf-5.png" /></p>

<p>Spring Framework의 또 다른 핵심 기능인 AOP 관점지향 프로그래밍을 담당한다.</p>

<p><br /></p>

<h3 id="aop가-도대체-뭐야">AOP가 도대체 뭐야?</h3>

<p>AOP는 Aspect Oriented Programming 관점 지향 프로그래밍이다.</p>

<p><img src="/assets/img/contents/sf-6.png" alt="sf-6.png" /></p>

<p>핵심 기능(비즈니스 로직)에서 부가 기능(로깅, 트랜잭션, 예외)을 분리하기 위하여 횡단 분리(cross-cutting)하는 것(관점)</p>

<p>Aspect로 분리하여 공통 기능을 비즈니스 로직과 코드에 영향을 주지 않게 적용할 수 있다.</p>

<p><br /></p>

<h3 id="aop를-왜-써">AOP를 왜 써?</h3>

<p>아래와 같은 DAO가 있다고 하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAccount</span><span class="o">(</span><span class="nc">Account</span> <span class="n">account</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="n">sessionFactory</span><span class="o">.</span><span class="na">getCurrentSession</span><span class="o">();</span>
	<span class="n">currentSession</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">account</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>로깅과 보안 처리에 대한 요구사항이 들어왔다.</p>

<p>아래와 같이 코드는 늘어날 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAccount</span><span class="o">(</span><span class="nc">Account</span> <span class="n">account</span><span class="o">,</span> <span class="nc">String</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 로깅 코드 </span>
	<span class="c1">// 보안 체크</span>
	<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="n">sessionFactory</span><span class="o">.</span><span class="na">getCurrentSession</span><span class="o">();</span>
	<span class="n">currentSession</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">account</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>보안 체크시 사용하기 위한 userId라는 새로운 인자가 추가되었다.</p>

<p>로깅을 DAO뿐만이 아니라 서비스와 컨트롤러에도 적용하고 싶다면 아래와 같이 코드는 늘어날 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccountService</span><span class="o">{</span>
	<span class="c1">// 로깅 코드</span>
	<span class="c1">// 보안 체크</span>
	<span class="n">accountDAO</span><span class="o">.</span><span class="na">addAccount</span><span class="o">(</span><span class="n">account</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccountController</span><span class="o">{</span>
	<span class="c1">// 로깅 코드</span>
	<span class="c1">// 보안 체크</span>
	<span class="n">accountService</span><span class="o">.</span><span class="na">addAccount</span><span class="o">(</span><span class="n">account</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>동일한 기능을 하는 중복코드가 벌써 3개나 생겨버렸다.</p>

<p>만약 이 기능을  addAccount 메소드가 아닌 모든 메서드에 적용하고 싶다면?</p>

<p>해당 기능을 구현했는데 보안 체크 로직을 바꿔달라는 요구사항이 온다면?</p>

<p>해당 클래스가 2, 3개라면 큰 문제가 없겠지만 100개 아니 1000개라면 상상도 하기 싫다.</p>

<p><br /></p>

<h3 id="oop로-해결해보자-oop의-한계">OOP로 해결해보자, OOP의 한계</h3>

<h4 id="1-상속을-쓰면-되잖아">1. 상속을 쓰면 되잖아</h4>

<p>객체지향이 좋은게 뭐겠어? =&gt; 상속과 다형성이지</p>

<p>한번 해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Logging</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">logging</span><span class="o">(){</span>
    <span class="c1">// logging</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccountService</span> <span class="kd">extends</span> <span class="nc">Logging</span> <span class="o">{</span>
	<span class="n">logging</span><span class="o">();</span>
	<span class="n">accountDAO</span><span class="o">.</span><span class="na">addAccount</span><span class="o">(</span><span class="n">account</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccountController</span> <span class="kd">extends</span> <span class="nc">Logging</span> <span class="o">{</span>
	<span class="n">logging</span><span class="o">();</span>
	<span class="n">accountService</span><span class="o">.</span><span class="na">addAccount</span><span class="o">(</span><span class="n">account</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Logging 기능을 담당하는 부모 클래스를 만들고 로깅을 필요로하는 모든 클래스에 대하여 상속을 하였다.</p>

<p><strong>문제는 Java에서는 다중 상속을 지원하지 않는다.</strong></p>

<p>별도의 인터페이스를 상속 받는 클래스에는 사용이 불가능하다.</p>

<p>마찬가지로 다중상속이 안되어 보안 처리에 대한 클래스를 별도로 분리할 수 없다.</p>

<p><br /></p>

<h4 id="2-위임delegation을-써보자">2. 위임(Delegation)을 써보자</h4>

<p>그럼 상속이 아닌 위임으로는?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Logging</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">logging</span><span class="o">(){</span>
    <span class="c1">// logging</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Security</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkSecurity</span><span class="o">(){</span>
    <span class="c1">// security</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccountServiceImpl</span> <span class="kd">implements</span> <span class="nc">AccountService</span> <span class="o">{</span>
	<span class="nc">Logging</span> <span class="n">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Logging</span><span class="o">();</span>
	<span class="nc">Security</span> <span class="n">security</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Security</span><span class="o">();</span>
	<span class="n">logger</span><span class="o">.</span><span class="na">logging</span><span class="o">();</span>
	<span class="n">security</span><span class="o">.</span><span class="na">checkSecurity</span><span class="o">();</span>
	<span class="n">accountDAO</span><span class="o">.</span><span class="na">addAccount</span><span class="o">(</span><span class="n">account</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccountController</span> <span class="kd">extends</span> <span class="nc">Logging</span> <span class="o">{</span>
	<span class="nc">Logging</span> <span class="n">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Logging</span><span class="o">();</span>
	<span class="nc">Security</span> <span class="n">security</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Security</span><span class="o">();</span>
	<span class="n">logger</span><span class="o">.</span><span class="na">logging</span><span class="o">();</span>
	<span class="n">security</span><span class="o">.</span><span class="na">checkSecurity</span><span class="o">();</span>
	<span class="n">accountService</span><span class="o">.</span><span class="na">addAccount</span><span class="o">(</span><span class="n">account</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>언뜻 보기에는 위 상속 버전에서 발생한 다중상속을 해결하여 문제를 해결한 것 처럼 보이나</p>

<p>결론적으로는 코드의 복잡도만 늘어났고 로깅/보안 체크 수정시에는 모든 클래스를 수정해야하는 문제가 있다.</p>

<p><br /></p>

<h3 id="aop를-사용한다면">AOP를 사용한다면</h3>

<p>기존의 OOP를 이용하여 문제를 해결할 수는 있으나 아름다운 코드라고는 할 수 없다.</p>

<p>이러한 문제를 해결하기 위하여 나온 개념이 관점 지향 프로그래밍 AOP이다.</p>

<h4 id="장점">장점</h4>

<ol>
  <li>AOP를 사용한다면 Aspect 코드를 단일 클래스에서 관리할 수 있다.
    <ul>
      <li>로깅 코드를 수정하고 싶다면 해당 Aspect만 수정하면 되는 것이다.</li>
    </ul>
  </li>
  <li>소스코드의 비즈니스 로직과 부가 기능 로직을 분리할 수 있다.
    <ul>
      <li>비즈니스 로직 기능에만 충실하도록 코드를 작성할 수 있어 가독성이 높아진다.</li>
    </ul>
  </li>
  <li>어플리케이션 코드 수정 없이 원하는 부분에만 적용이 가능하다.
    <ul>
      <li>예외 발생시, 메서드 호출 전, 후 등</li>
    </ul>
  </li>
</ol>

<h4 id="단점">단점</h4>

<ol>
  <li>많은 수의 Aspect는 어플리케이션 호출 흐름을 이해하기 어렵게 만든다.
    <ul>
      <li>관점 지향 프로그래밍에서는 비즈니스 로직과 Aspect 로직이 분리되므로 많은 부분에 AOP가 적용된다면 흐름을 이해하기 힘들 수 있다.</li>
    </ul>
  </li>
  <li>아주 약간의 성능 저하(런타임 Weaving의 경우에만 한함)
    <ul>
      <li>런타임에 위빙을 하는 경우 실행시 미미하지만 약간의 성능 지연이 발생할 수 있다.</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h3 id="aop-용어-정리">AOP 용어 정리</h3>

<p><img src="/assets/img/contents/sf-8.png" alt="sf-8.png" /></p>

<h4 id="advice">Advice</h4>

<p>어떤 액션을 취할지 정의한 공통 코드(실제 구현 코드)</p>

<p>Advice에는 시점에 따른 5가지 타입이 있다.</p>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>시점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Before</td>
      <td>메소드 실행 전</td>
    </tr>
    <tr>
      <td>After finally</td>
      <td>메소드 실행 후(finally)</td>
    </tr>
    <tr>
      <td>After returning</td>
      <td>메소드 실행 후(success)</td>
    </tr>
    <tr>
      <td>After throwing</td>
      <td>메소드 실행 후(exception)</td>
    </tr>
    <tr>
      <td>Around</td>
      <td>메소드 실행 전, 메소드 실행 후</td>
    </tr>
  </tbody>
</table>

<h4 id="join-point">Join Point</h4>

<p>Aspect가 해당 코드의 어느 시점에(어디에) 적용되는지 정의한 지점으로 포인트컷의 후보군이 된다.</p>

<h4 id="pointcut">Pointcut</h4>

<p>조인포인트중 표현식을 통해 필터링한 특정 조인포인트로 적용 대상을 결정</p>

<h4 id="aspect">Aspect</h4>

<p>횡단 관심사로 어떤 포인트컷에 어떤 어드바이스를 취할지 정의된 코드 모듈(로그 출력, 캐싱, 예외처리 등)</p>

<p><br /></p>

<h4 id="weaving">Weaving</h4>

<p>Aspect를 목표 타겟 객체에 연결하는 것</p>

<p>컴파일타임 위빙, 로드타임 위빙, 런타임 위빙이 있다.</p>

<blockquote>
  <p>컴파일타임 위빙은 추가적인 컴파일 단계가 필요하며 런타임 위빙이 가장 느리다.</p>
</blockquote>

<p><br /></p>

<h3 id="aop-프레임워크">AOP 프레임워크</h3>

<ul>
  <li>Spring AOP</li>
  <li>AspectJ</li>
</ul>

<p>Java의 대표적인 두 가지 AOP 프레임워크를 지원한다.</p>

<p><br /></p>

<h3 id="spring-aop-1">Spring AOP</h3>

<p><img src="/assets/img/titles/spring-icon-logo.png" alt="spring-icon-logo.png" /></p>

<div class="mermaid">
  flowchart LR
    A[Application]
    B[AOP Proxy]
    C[Logging Aspect]
    D[Security Aspect]
    E[Target Object]
    A--&gt;B---C---D--&gt;E
</div>

<p>Spring 프레임워크에서 기본적으로 제공하는 AOP이며 일반 AOP 인터페이스를 기반으로한 새로운 인터페이스이다.</p>

<p>스프링 프레임워크 뒷단에서는 보안, 트랜잭션, 캐싱등을 구현할때 Spring AOP를 사용한다고 한다.</p>

<p>AOP Proxy를 통하여 Aspect 위빙된 타겟 어플리케이션과 통신한다.</p>

<blockquote>
  <p>Spring AOP는 AOP 인터페이스의 일부만을 구현하고 있다.</p>

  <p>따라서 특정 기능을 사용하려면 결국 AspectJ 라이브러리가 필요하다.</p>
</blockquote>

<p><br /></p>

<h4 id="장점-1">장점</h4>

<ol>
  <li>AspectJ 보다 사용이 간단하다.</li>
  <li>프록시 패턴을 사용한다.</li>
  <li>@Aspect 애노테이션을 통해 AspectJ로의 이관이 쉽게 가능하다.</li>
</ol>

<h4 id="단점-1">단점</h4>

<ol>
  <li>메소드 레벨의 조인포인트만 가능하다.</li>
  <li>스프링 컨테이너의 Bean에만 적용이 가능하다.</li>
  <li>런타임 위빙으로 약간의 성능 저하가 있을 수 있다.</li>
</ol>

<p><br /></p>

<h3 id="aspectj">AspectJ</h3>

<p><a href="https://www.eclipse.org/aspectj">https://www.eclipse.org/aspectj</a></p>

<p>AOP 인터페이스의 확실한 구현체 프레임워크로 2001년에 발표된 오리지널 AOP 프레임워크이다.</p>

<p>AOP 기능의 모든 기능을 지원하며 생성자, 필드 joinpoint 및 컴파일 타임, 로드타임 위빙을 지원한다.</p>

<p><br /></p>

<h4 id="장점-2">장점</h4>

<ol>
  <li>모든 조인포인트를 지원한다.</li>
  <li>스프링 빈뿐만이 아니라 POJO도 지원한다.</li>
  <li>Spring AOP에 비해 더 좋은 성능을 가진다.</li>
  <li>AOP의 모든 기능을 제공한다.</li>
</ol>

<h4 id="단점-2">단점</h4>

<ol>
  <li>컴파일타임 위빙은 추가적인 컴파일 단계를 필요로함</li>
  <li>포인트컷 문법이 좀 더 복잡하다.</li>
</ol>

<p><br /></p>

<h3 id="spring-aop-vs-aspectj">Spring AOP vs AspectJ</h3>

<table>
  <thead>
    <tr>
      <th>비교군</th>
      <th>AspectJ</th>
      <th>Spring AOP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>조인포인트</td>
      <td>메소드, 생성자, 필드</td>
      <td>메소드</td>
    </tr>
    <tr>
      <td>위빙</td>
      <td>컴파일타임, 포스트 컴파일타임, 로드타임</td>
      <td>런타임</td>
    </tr>
    <tr>
      <td>성능</td>
      <td>비교적 빠름(컴파일타임 위빙)</td>
      <td>비교적 느림(런타임 위빙)</td>
    </tr>
    <tr>
      <td>타겟</td>
      <td>Spring Bean, POJO</td>
      <td>Spring Bean</td>
    </tr>
  </tbody>
</table>

<p>AspectJ는 AOP의 완전한 구현체를 목표로 하고 있으므로 AOP 인터페이스의 모든 기능을 지원한다.</p>

<p>하지만 Spring AOP는 AOP의 상위 인터페이스이자 AOP의 일부 구현체로 모든 기능을 지원하지 않는다.</p>

<p>경우에 따라 AspectJ의 구현체를 요구하므로 실질적으로 사용시에는 AspectJ 라이브러리를 포함하게 될 것이다.</p>

<p><br /></p>

<h3 id="aspect-예제">Aspect 예제</h3>

<h4 id="1-특정-메소드-호출-이전-aop">1. 특정 메소드 호출 이전 AOP</h4>

<h4 id="aspect-1">Aspect</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Aspect</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoggingAspect</span> <span class="o">{</span>
	<span class="nd">@Before</span><span class="o">(</span><span class="s">"execution(public void getUser())"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"@Before Advice on method"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="target">Target</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDAO</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">getUser</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">+</span> <span class="s">"UserDAO.getUser()"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="main">Main</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">ApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="nc">UserDAO</span> <span class="n">userDAO</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"userDAO"</span><span class="o">,</span> <span class="nc">UserDAO</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
		<span class="n">userDAO</span><span class="o">.</span><span class="na">getUser</span><span class="o">();</span>
		<span class="o">((</span><span class="nc">AbstractApplicationContext</span><span class="o">)</span><span class="n">ctx</span><span class="o">).</span><span class="na">close</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="실행결과">실행결과</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Before Advice on method
class com.csupreme19.aopdemo.dao.UserDAOUserDAO.getUser()
</code></pre></div></div>

<p><br /></p>

<h3 id="pointcut-designatorpcd">Pointcut Designator(PCD)</h3>

<p>포인트컷 지정자로 포인트컷에 해당하는 문자열은 다음과 같은 패턴을 가진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(접근 지정자? 리턴타입 패키지.클래스? 메소드명(파라미터명) throws Exception?)"</span><span class="o">)</span>
<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"within(패키지.클래스)"</span><span class="o">)</span>
<span class="c1">// 이 외에도 @target, @annotation 등의 PCD들이 존재한다.</span>
</code></pre></div></div>

<p>뒤에 ?가 붙은 것은 Optional 패턴으로 비어 있어도 상관 없음</p>

<blockquote>
  <p>접근지정자는 public만 사용 가능하다.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 예시</span>
<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(public void com.csupreme19.demo.myClass.methodA() throws RuntimeException)"</span><span class="o">)</span>
<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"within(com.csupreme19.demo.myClass)"</span><span class="o">)</span>

<span class="c1">// 필수 패턴만 적을시</span>
<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(void methodA())"</span><span class="o">)</span>

<span class="c1">// * asterisk로 문자열 대치 가능</span>
<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(* method*())"</span><span class="o">)</span>

<span class="c1">// (): 파라미터 없음</span>
<span class="c1">// (*): 단일 파라미터 대치</span>
<span class="c1">// (..): 모든 파라미터 대치</span>
<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(* get*(..))"</span><span class="o">)</span>

<span class="c1">// &amp;&amp;(and), ||(or), !(not) 3가지 논리 연산자 가능</span>
<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(* get*(..)) || execution(* set*(..))"</span><span class="o">)</span>

<span class="c1">// Pointcut 선언적으로 사용 가능</span>
<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(* get*(..))"</span><span class="o">)</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">getter</span><span class="o">()</span> <span class="o">{}</span>

<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(* set*(..))"</span><span class="o">)</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">setter</span><span class="o">()</span> <span class="o">{}</span>

<span class="nd">@Before</span><span class="o">(</span><span class="s">"getter() || setter()"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nf">void</span> <span class="o">()</span> <span class="o">{}</span>
</code></pre></div></div>

<p>포인트컷은</p>

<p>해당 포인트컷을 메서드로 정의하여 아래와 같이 사용하는 것도 가능하다.</p>

<p><br /></p>

<h3 id="aspect-order">Aspect Order</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Aspect</span>
<span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoggingAspect</span> <span class="o">{</span>
	<span class="nd">@Before</span><span class="o">(</span><span class="s">"execution(* get*())"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"@Before Advice on get method"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Aspect</span>
<span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityAspect</span> <span class="o">{</span>
	<span class="nd">@Before</span><span class="o">(</span><span class="s">"execution(* set*(..))"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"@Before Advice on set method"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">@Order(Integer)</code> 어노테이션으로 순서 명시 가능 작은 수일 수록 먼저 실행된다.</p>

<p><br /></p>

<h3 id="aop-best-practices">AOP Best Practices</h3>

<p>AOP는 공통 관심사로 공통 로직을 담당하므로 아래와 같이 작성하는 것이 좋다.</p>

<ul>
  <li>코드는 최대한 간결하게</li>
  <li>코드는 최대한 빠르게</li>
  <li>무겁고 느린 연산 피하기</li>
</ul>

<hr />

<h2 id="reference">Reference</h2>

<ol>
  <li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html#overview">docs.spring.io overview</a></li>
  <li><a href="https://docs.spring.io/spring-framework/docs/5.0.0.M5/spring-framework-reference/html/overview.html">docs.spring.io 5.0.0 overview</a></li>
  <li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core">docs.spring.io spring-core</a></li>
  <li><a href="https://www.udemy.com/course/spring-hibernate-tutorial/">Udemy Spring &amp; Hibernate for Beginners</a></li>
  <li><a href="http://www.yes24.com/Product/Goods/59192207">스프링 철저 입문</a></li>
</ol>

:ET